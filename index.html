<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>근무현황표 생성기</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 10px;
            background-color: #f4f4f4;
        }
        .controls {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
        }
        .controls label {
            font-weight: bold;
            margin-right: 5px;
        }
        .controls input[type="number"],
        .controls select {
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 70px;
        }
        .controls input[type="radio"] {
            margin-left: 10px;
        }
        .controls button, .controls a.button-link {
            padding: 8px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 15px;
            margin-right: 8px;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            white-space: nowrap;
        }
        .controls button:hover, .controls a.button-link:hover {
            background-color: #0056b3;
        }
        #scheduleContainer {
            background-color: white;
            padding: 10px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            margin: 20px auto;
            width: 27.7cm;
        }
        table {
            width: 27.7cm;
            border-collapse: collapse;
            margin: 0 auto;
            font-size: 0.75em;
            background-color: #fff;
            table-layout: fixed;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 4px;
            text-align: center;
            vertical-align: top;
            line-height: 1.1;
            word-break: keep-all;
            height: 38px;
            box-sizing: border-box;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        th:nth-child(1), td:nth-child(1) { width: 2.5cm; }
        th:nth-child(2), td:nth-child(2) { width: 2.5cm; }
        th:nth-child(3), td:nth-child(3) { width: 3.8cm; }
        th:nth-child(4), td:nth-child(4) { width: 3.8cm; }
        th:nth-child(5), td:nth-child(5) { width: 3.8cm; }
        th:nth-child(6), td:nth-child(6) { width: 3.8cm; }
        th:nth-child(7), td:nth-child(7) { width: 3.8cm; }
        th:nth-child(8), td:nth-child(8) { width: 3.8cm; }
        caption {
            font-size: 1.2em;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
            text-decoration: underline;
        }
        .sunday {
            background-color: #ffe0e0;
        }
        .saturday {
            background-color: #e0e0ff;
        }
        .holiday {
            background-color: #ffcccc;
            font-weight: bold;
            color: #cc0000;
        }
        .edit-mode {
            position: relative;
            padding: 2px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            height: 100%;
        }
        .edit-mode input {
            width: calc(100% - 8px); /* 패딩 및 보더 고려 */
            margin-bottom: 2px;
            padding: 2px;
            box-sizing: border-box;
        }
        .edit-mode .cell-buttons {
            display: flex;
            justify-content: space-around;
            margin-top: 2px;
        }
        .edit-mode .cell-buttons button {
            padding: 3px 5px;
            font-size: 0.7em;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            white-space: nowrap;
        }
        .edit-mode .cell-buttons button.btn-temp {
            background-color: #ffc107;
        }
        .edit-mode .cell-buttons button.btn-cancel {
            background-color: #dc3545;
        }
        .name-entry {
            display: block;
            margin-top: 2px;
            margin-bottom: 2px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <label for="yearInput">년도:</label>
        <input type="number" id="yearInput" value="2025">
        <label for="monthInput">월:</label>
        <input type="number" id="monthInput" value="9">
        
        <input type="radio" id="option1" name="displayOption" value="1" checked>
        <label for="option1">1일 ~ 15일</label>
        <input type="radio" id="option2" name="displayOption" value="2">
        <label for="option2">16일 ~ 말일</label>
        
        <button onclick="generateSchedule()">생성</button>
        <button onclick="saveAsPdf()">PDF 저장</button>
        <button onclick="printAsPdf()">PDF 인쇄</button>
        <a href="https://waryong2025.github.io/timeman/" class="button-link" target="_blank">07번 배차표</a>
        <a href="https://waryong2025.github.io/townbus/" class="button-link" target="_blank">08번배차표</a>
    </div>
    <div id="scheduleContainer" style="background-color: white; padding: 10px;">
        <table>
            <caption id="tableCaption">종로 07번 2025년 9월 1일 ~ 15일까지 근무현황표</caption>
            <thead>
                <tr>
                    <th>월일</th>
                    <th>요일</th>
                    <th>3613</th>
                    <th>3612</th>
                    <th>5536호</th>
                    <th>5537</th>
                    <th>5518</th>
                    <th>기 타</th>
                </tr>
            </thead>
            <tbody id="scheduleBody">
            </tbody>
        </table>
    </div>
    <script>
        // **수정**: localStorage에서 고정 데이터를 불러오거나, 없으면 빈 객체로 시작
        let fixedScheduleData = JSON.parse(localStorage.getItem('jongro07FixedSchedule')) || {};
        
        // 임시 스케줄 데이터 (페이지 로딩 시점에만 유효)
        let scheduleData = {};
        
        const getDayName = (dayIndex) => {
            const days = ['일', '월', '화', '수', '목', '금', '토'];
            return days[dayIndex];
        };

        const getLastDayOfMonth = (year, month) => {
            return new Date(year, month, 0).getDate();
        };

        const isPublicHoliday = (date) => {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const formattedDate = `${year}-${month}-${day}`;

            const holidays2025 = new Set([
                "2025-01-01", "2025-01-28", "2025-01-29", "2025-01-30",
                "2025-03-01", "2025-05-05", "2025-06-02", "2025-06-06",
                "2025-08-15", "2025-10-03", "2025-10-06", "2025-10-09",
                "2025-12-25"
            ]);

            return holidays2025.has(formattedDate);
        };

        const renderCellContent = (namesArray) => {
            if (!namesArray || (namesArray[0] === '' && namesArray[1] === '')) {
                return '';
            }
            let content = '';
            if (namesArray[0]) {
                content += `<span class="name-entry">${namesArray[0]}</span>`;
            }
            if (namesArray[1]) {
                if (content !== '') {
                    content += '<br>';
                }
                content += `<span class="name-entry">${namesArray[1]}</span>`;
            }
            return content;
        };

        function editCell(cellElement, colId, dateString) {
            if (cellElement.classList.contains('edit-mode')) {
                return;
            }

            const currentNames = (scheduleData[dateString] && scheduleData[dateString][colId]) || 
                                 (fixedScheduleData[dateString] && fixedScheduleData[dateString][colId]) || 
                                 ['', ''];
            
            cellElement.dataset.colId = colId;
            cellElement.dataset.dateString = dateString;

            cellElement.classList.add('edit-mode');
            
            cellElement.innerHTML = `
                <input type="text" class="morning-input" value="${currentNames[0] || ''}" placeholder="오전 명단">
                <input type="text" class="afternoon-input" value="${currentNames[1] || ''}" placeholder="오후 명단">
                <div class="cell-buttons">
                    <button class="btn-fixed" onclick="saveFixedCell(this.parentNode.parentNode)">고정</button>
                    <button class="btn-temp" onclick="saveTempCell(this.parentNode.parentNode)">임시</button>
                    <button class="btn-cancel" onclick="resetCell(this.parentNode.parentNode)">초기화</button>
                </div>
            `;
        }

        function getNamesFromInput(cellElement) {
            const morningInput = cellElement.querySelector('.morning-input');
            const afternoonInput = cellElement.querySelector('.afternoon-input');
            const newMorningName = morningInput.value.trim();
            const newAfternoonName = afternoonInput ? afternoonInput.value.trim() : '';
            return [newMorningName, newAfternoonName];
        }

        function saveFixedCell(cellElement) {
            const colId = cellElement.dataset.colId;
            const dateString = cellElement.dataset.dateString;
            const newNames = getNamesFromInput(cellElement);

            if (!fixedScheduleData[dateString]) {
                fixedScheduleData[dateString] = {};
            }
            fixedScheduleData[dateString][colId] = newNames;

            // **수정**: 변경된 고정 데이터를 localStorage에 저장
            localStorage.setItem('jongro07FixedSchedule', JSON.stringify(fixedScheduleData));

            // 임시 데이터에도 반영하여 즉시 표시
            if (!scheduleData[dateString]) {
                scheduleData[dateString] = {};
            }
            scheduleData[dateString][colId] = newNames;

            cellElement.classList.remove('edit-mode');
            cellElement.innerHTML = renderCellContent(newNames);
        }

        function saveTempCell(cellElement) {
            const colId = cellElement.dataset.colId;
            const dateString = cellElement.dataset.dateString;
            const newNames = getNamesFromInput(cellElement);

            if (!scheduleData[dateString]) {
                scheduleData[dateString] = {};
            }
            scheduleData[dateString][colId] = newNames;
            
            cellElement.classList.remove('edit-mode');
            cellElement.innerHTML = renderCellContent(newNames);
        }

        function resetCell(cellElement) {
            const colId = cellElement.dataset.colId;
            const dateString = cellElement.dataset.dateString;

            // 고정 데이터에서 해당 셀 정보 삭제
            if (fixedScheduleData[dateString] && fixedScheduleData[dateString][colId]) {
                delete fixedScheduleData[dateString][colId];
            }
            // 임시 데이터는 generateSchedule() 호출 시 자동으로 초기화됨

            // **수정**: 변경된 고정 데이터를 localStorage에 저장
            localStorage.setItem('jongro07FixedSchedule', JSON.stringify(fixedScheduleData));

            // 스케줄을 다시 생성하여 원래 값으로 복원
            generateSchedule();
        }

        function generateSchedule() {
            const year = parseInt(document.getElementById('yearInput').value);
            const month = parseInt(document.getElementById('monthInput').value);
            const selectedOption = document.querySelector('input[name="displayOption"]:checked').value;
            const scheduleBody = document.getElementById('scheduleBody');
            const tableCaption = document.getElementById('tableCaption');

            // 임시 데이터는 항상 초기화
            scheduleData = {};

            let startDate, endDate;
            if (selectedOption === '1') {
                startDate = new Date(year, month - 1, 1);
                endDate = new Date(year, month - 1, 15);
            } else {
                startDate = new Date(year, month - 1, 16);
                endDate = new Date(year, month - 1, getLastDayOfMonth(year, month));
            }

            startDate.setHours(0, 0, 0, 0);
            endDate.setHours(0, 0, 0, 0);

            tableCaption.textContent = `종로 07번 ${year}년 ${month}월 ${startDate.getDate()}일 ~ ${endDate.getDate()}일까지 근무현황표`;
            scheduleBody.innerHTML = '';

            const baseDate = new Date(2025, 8, 1); // 9월 1일 기준
            baseDate.setHours(0, 0, 0, 0);
            
            let currentDate = new Date(startDate);
            
            while (currentDate.getTime() <= endDate.getTime()) {
                const day = currentDate.getDate();
                const dayOfWeek = currentDate.getDay();
                const dayName = getDayName(dayOfWeek);
                const isHoliday = isPublicHoliday(currentDate);
                const dateString = currentDate.toISOString().slice(0, 10);

                let cellsContent = {
                    '3613': ['', ''], '3612': ['', ''], '5536호': ['', ''],
                    '5537': ['', ''], '5518': ['', ''], '기 타': ['', '']
                };

                // 1. 기본 로테이션 및 규칙 적용
                if (!(dayOfWeek === 0 || isHoliday)) {
                    let firstMondayOfCurrentWeek = new Date(currentDate);
                    const dayOfWeekForRotation = firstMondayOfCurrentWeek.getDay();
                    const daysToSubtract = (dayOfWeekForRotation === 0) ? 6 : dayOfWeekForRotation - 1;
                    firstMondayOfCurrentWeek.setDate(firstMondayOfCurrentWeek.getDate() - daysToSubtract);
                    firstMondayOfCurrentWeek.setHours(0, 0, 0, 0);

                    const diffTime = firstMondayOfCurrentWeek.getTime() - baseDate.getTime();
                    let weeksPassed = Math.floor(diffTime / (1000 * 60 * 60 * 24 * 7));
                    
                    let initialNames3613 = ['이미휴', '강명희']; 
                    let initialNames5537 = ['이기용', '정형택']; // 요청에 따라 '이기용'님과 '정형택'님의 순서를 변경했습니다.
                    let initialNames5536 = ['최창희', '송명석'];

                    if (weeksPassed % 2 !== 0) {
                        initialNames3613.reverse();
                        initialNames5537.reverse();
                        initialNames5536.reverse();
                    }

                    cellsContent['3613'] = initialNames3613;
                    cellsContent['5536호'] = initialNames5536;

                    // ==================== ✨ 수정된 부분 ✨ ====================
                    // 5537번의 토요일 근무자를 고정하고, 5518번의 토요일 근무를 원래대로 되돌렸습니다.
                    if (dayOfWeek === 6) { // 토요일인 경우
                        cellsContent['5537'] = ['오부장', '정형택'];
                    } else { // 평일인 경우
                        cellsContent['5537'] = initialNames5537;
                    }
                    
                    cellsContent['5518'] = (dayOfWeek === 6) ? ['김영환', ''] : ['', '권과장'];
                    // =======================================================
                }

                // 2. 고정 데이터가 있다면 기본값을 덮어쓰기
                if (fixedScheduleData[dateString]) {
                    Object.assign(cellsContent, fixedScheduleData[dateString]);
                }
                
                scheduleData[dateString] = cellsContent;

                let rowClass = '';
                if (dayOfWeek === 0) rowClass = 'sunday';
                else if (dayOfWeek === 6) rowClass = 'saturday';
                else if (isHoliday) rowClass = 'holiday';

                const row = `
                    <tr class="${rowClass}">
                        <td>${day}</td>
                        <td>${dayName}</td>
                        <td onclick="editCell(this, '3613', '${dateString}')">${renderCellContent(cellsContent['3613'])}</td>
                        <td onclick="editCell(this, '3612', '${dateString}')">${renderCellContent(cellsContent['3612'])}</td>
                        <td onclick="editCell(this, '5536호', '${dateString}')">${renderCellContent(cellsContent['5536호'])}</td>
                        <td onclick="editCell(this, '5537', '${dateString}')">${renderCellContent(cellsContent['5537'])}</td>
                        <td onclick="editCell(this, '5518', '${dateString}')">${renderCellContent(cellsContent['5518'])}</td>
                        <td onclick="editCell(this, '기 타', '${dateString}')">${renderCellContent(cellsContent['기 타'])}</td>
                    </tr>
                `;
                scheduleBody.insertAdjacentHTML('beforeend', row);

                currentDate.setDate(currentDate.getDate() + 1);
            }
        }

        const pdfOptions = {
            margin: [10, 10, 10, 10],
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: {
                scale: 1.0, logging: false, dpi: 192,
                letterRendering: true, background: '#ffffff'
            },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' }
        };

        function saveAsPdf() {
            const element = document.getElementById('scheduleContainer');
            const captionText = document.getElementById('tableCaption').textContent;
            const filename = captionText.replace(/[^a-zA-Z0-9가-힣\s]/g, '').replace(/ /g, '_') + '.pdf';

            document.querySelectorAll('.edit-mode').forEach(cell => {
                const colId = cell.dataset.colId;
                const dateString = cell.dataset.dateString;
                cell.classList.remove('edit-mode');
                cell.innerHTML = renderCellContent(scheduleData[dateString][colId]);
            });

            html2pdf().set({ ...pdfOptions, filename: filename }).from(element).save();
        }

        function printAsPdf() {
            const element = document.getElementById('scheduleContainer');
            const captionText = document.getElementById('tableCaption').textContent;
            const filename = captionText.replace(/[^a-zA-Z0-9가-힣\s]/g, '').replace(/ /g, '_') + '.pdf';
            
            document.querySelectorAll('.edit-mode').forEach(cell => {
                const colId = cell.dataset.colId;
                const dateString = cell.dataset.dateString;
                cell.classList.remove('edit-mode');
                cell.innerHTML = renderCellContent(scheduleData[dateString][colId]);
            });

            html2pdf().set({ ...pdfOptions, filename: filename })
                .from(element)
                .outputPdf('datauristring')
                .then(function(pdfDataUri) {
                    const newWindow = window.open();
                    newWindow.document.write('<iframe width="100%" height="100%" src="' + pdfDataUri + '"></iframe>');
                });
        }
        
        document.addEventListener('DOMContentLoaded', generateSchedule);
        window.onload = generateSchedule;

    </script>
</body>
</html>
